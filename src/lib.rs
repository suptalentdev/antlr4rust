#![crate_type = "lib"]
#![feature(try_blocks)]
//#![feature(nll)]
#![feature(raw)]
#![feature(inner_deref)]
#![feature(is_sorted)]
#![feature(cell_update)]
#![feature(get_mut_unchecked)]
#![feature(specialization)]
#![feature(coerce_unsized)]
#![feature(unsize)]
#![feature(associated_type_defaults)]
#![warn(rust_2018_idioms)]
#![warn(missing_docs)] // warn if there is missing docs
#![warn(missing_debug_implementations)]
#![warn(trivial_numeric_casts)]
//! # Antlr4 runtime
//!
//! !! not production ready, but pretty close.
//! Api very likely will be changed,
//! but it is fully functional so you can use it for experimentation and proof of concepts.
//!
//! This is a Rust runtime for [ANTLR4] parser generator.
//! It is required to use parsers and lexers generated by [ANTLR4] parser generator
//!
//! This documentation refers to particular api used by generated parsers,lexers and syntax trees.
//!
//! For info on how to generate parser please refer to:
//!  - [ANTLR4] main repository
//!  - [README](https://github.com/rrevenantt/antlr4rust/blob/master/README.md) for Rust target
//!
//! [ANTLR4]: https://github.com/antlr/antlr4

// To anyone going to change this code in the future:
// Architecture notes:
// todo
//

#[macro_use]
extern crate lazy_static;

#[doc(hidden)]
pub use lazy_static::lazy_static;

#[doc(inline)]
pub use error_strategy::{BailErrorStrategy, DefaultErrorStrategy, ErrorStrategy};
#[doc(inline)]
pub use input_stream::InputStream;
// #[doc(inline)]
// pub use input_stream::CodePointInputStream;
#[doc(inline)]
pub use lexer::{BaseLexer, Lexer};
#[doc(inline)]
pub use parser::{BaseParser, ListenerId, Parser};
//extern crate uuid;
#[doc(inline)]
pub use prediction_context::PredictionContextCache;

mod ll1_analyzer;
pub mod token_factory;
pub mod recognizer;
pub mod int_stream;
mod lexer_action;
pub mod atn_simulator;
pub mod atn_config;
//pub mod tokenstream_rewriter;
#[doc(hidden)]
pub mod semantic_context;
#[doc(hidden)]
pub mod dfa_state;
#[doc(hidden)]
pub mod atn_state;
pub mod parser_rule_context;
mod prediction_context;
pub mod interval_set;
pub mod token_source;
#[doc(hidden)]
pub mod atn_deserialization_options;
pub mod token_stream;
pub mod char_stream;
//pub mod trace_listener;
#[doc(hidden)]
pub mod transition;
pub mod tree;
#[doc(hidden)]
pub mod dfa;
//pub mod file_stream;
#[doc(hidden)]
pub mod atn_deserializer;
pub mod token;
mod utils;
pub mod trees;
#[doc(hidden)]
pub mod atn_config_set;
pub mod error_listener;
pub mod prediction_mode;
mod input_stream;
pub mod common_token_stream;
pub mod lexer;
mod dfa_serializer;
pub mod lexer_atn_simulator;
#[doc(hidden)]
pub mod atn;
pub mod errors;
pub mod error_strategy;
#[doc(hidden)]
pub mod lexer_action_executor;
pub mod parser;
pub mod parser_atn_simulator;
//pub mod tokenstream_rewriter_test;
#[doc(hidden)]
pub mod atn_type;
pub mod rule_context;
pub mod vocabulary;

#[doc(hidden)]
#[macro_export]
macro_rules! type_id {
    ($struct: tt) => {
        unsafe impl antlr_rust::rule_context::Tid for $struct<'_> {
            fn self_id(&self) -> TypeId{
                core::any::TypeId::of::<$struct<'static>>()
            }
            fn id() -> TypeId where Self:Sized{
                core::any::TypeId::of::<$struct<'static>>()
            }

        }
    }
}

//#[cfg(test)]
// tests are either integration tests in "tests" foulder or unit tests in some modules
